# This script generates plots from the simulations outcomes generated by 1_script.jl
# Usage:
# 1) navigate to the project directory 'rl_cheap_talk' 
# 2) run 'julia --threads NUM_THREADS scripts/1_plots.jl -i INPUT_DIR'
#	 replacing NUM_THREADS with the desired number of threads 
#    and INPUT_DIR with the output directory of 1_script.jl 

using PGFPlotsX

include(joinpath(pwd(),"scripts","1_read_data.jl"))
extracted_data = read_data()

function plot_avg(data; legend = "", title = "", ylabel = "", color = "red", ymin = nothing, ymax = nothing, legend_pos = "", additional = "", width = raw"0.45\linewidth", height = raw"0.40\linewidth")
	# plot average value over all simulations and confidence interval 
	average = getindex.(data, 1)
    confidence_interval = hcat(getindex.(data, 2)...)'

    xticks = 1:10:length(set_biases)
    n_biases = length(set_biases)

    pl = @pgf Axis(
        {   xlabel = raw"$b$", 
            ylabel = ylabel,
            xmin = 1, 
            xmax = n_biases,
            ymin = ymin,
            ymax = ymax, 
            align = "center",
            title = title,
            xtick = xticks,
            xticklabels = string.(set_biases[xticks]),
            scaled_y_ticks = false,
            ylabel_style = "rotate=-90",
            tick_label_style = "{/pgf/number format/fixed, /pgf/number format/precision=4}",
            width = width, 
            height = height,
        }
    );
    !isempty(additional) && push!(pl.options, additional)
    legend_pos == "out_bottom" && push!(pl.options, raw"xlabel style={name=xlabel}")
    legend_pos == "out_bottom" && push!(pl.options, raw"legend style={at={(xlabel.south)},anchor=north,legend columns = -1, column sep = 5pt}")
    legend_pos == "out_right" && push!(pl.options, raw"legend style={at={(axis description cs:1.1,0.5)},anchor=west}")
    
    @pgf pl_avg = Plot({color = color}, Table(x = 1:n_biases, y = average));
	@pgf pl_ub = Plot({"name path=f", no_marks, thin, "draw=none", "forget plot"}, Table(x = 1:n_biases, y = confidence_interval[:,1]));
	@pgf pl_lb = Plot({"name path=g", no_marks, thin, "draw=none", "forget plot"}, Table(x = 1:n_biases, y = confidence_interval[:,2]));
	@pgf pl_fill = Plot({color = color, fill = color, opacity = 0.1, "forget plot"}, raw"fill between [of=f and g]");

	push!(pl, pl_avg);
	push!(pl, pl_ub);
	push!(pl, pl_lb);
	push!(pl, pl_fill);

    !isempty(legend) && push!(pl, LegendEntry(legend))

	return pl
end


function plot_avg!(pl, data; legend = "", color = "red")
	# plot average value over all simulations and confidence interval (adds on top to existing plot)
	average = getindex.(data, 1)
    confidence_interval = hcat(getindex.(data, 2)...)'

    n_biases = length(set_biases)

    @pgf pl_avg = Plot({color = color}, Table(x = 1:n_biases, y = average));
	@pgf pl_ub = Plot({"name path=f", no_marks, thin, "draw=none", "forget plot"}, Table(x = 1:n_biases, y = confidence_interval[:,1]));
	@pgf pl_lb = Plot({"name path=g", no_marks, thin, "draw=none", "forget plot"}, Table(x = 1:n_biases, y = confidence_interval[:,2]));
	@pgf pl_fill = Plot({color = color, fill = color, opacity = 0.1, "forget plot"}, raw"fill between [of=f and g]");

	push!(pl, pl_avg);
	push!(pl, pl_ub);
	push!(pl, pl_lb);
	push!(pl, pl_fill);

    !isempty(legend) && push!(pl, LegendEntry(legend))

	return pl
end


function plot_val!(pl, data; legend = "", color = "red", style = "solid")
	# plot value on top of existing plot
	val = getindex.(data,1)
    @pgf pl_val = Plot({color = color, style = style}, Table(x = 1:length(set_biases), y = val));
	push!(pl, pl_val);
    !isempty(legend) && push!(pl, LegendEntry(legend))
	return pl
end


function plot_eq_bound!(pl)
	# plot shaded areas to indicate where babbling is the unique equilibrium and where full communication is an equilibrium
	# last index at which mutual information is 1.0
	mi1_idx = findlast(extracted_data["best_mutual_information"] .== maximum(extracted_data["best_mutual_information"]))
	# first index at which mutual information is 0.0
	mi0_idx = findfirst(extracted_data["best_mutual_information"] .== minimum(extracted_data["best_mutual_information"]))
	@pgf pl_best_lx_bound = VLine({"draw=none", "name path=blx"}, 1)
	@pgf pl_best_rx_bound = VLine({"draw=none", "name path=brx"}, mi1_idx)
	@pgf pl_best_fill =  Plot({color = "gray", fill = "gray", opacity = 0.08}, raw"fill between [of=blx and brx]");
	@pgf pl_worst_lx_bound =  VLine({"draw=none", "name path=wlx"}, mi0_idx)
	@pgf pl_worst_rx_bound = VLine({"draw=none", "name path=wrx"}, length(set_biases))
	@pgf pl_worst_fill =  Plot({color = "gray", fill = "gray", opacity = 0.08}, raw"fill between [of=wlx and wrx]");
	push!(pl, pl_best_lx_bound);
	push!(pl, pl_best_rx_bound);
	push!(pl, pl_best_fill);
	push!(pl, pl_worst_lx_bound);
	push!(pl, pl_worst_rx_bound);
	push!(pl, pl_worst_fill);
end

# GENERATE PLOTS
push!(PGFPlotsX.CUSTOM_PREAMBLE, raw"\usepgfplotslibrary{fillbetween}")
# ex-ante expected reward sender
pl_expected_reward_s = plot_avg(extracted_data["avg_expected_reward_s"]; 
								title = "ex-ante expected reward (sender)",
								legend = "simulations", 
								color = "blue",
								legend_pos = "out_bottom");
pl_expected_reward_s = plot_val!(pl_expected_reward_s, extracted_data["best_expected_reward_s"]; legend = "optimal equilibrium", color="red");
pl_expected_reward_s = plot_val!(pl_expected_reward_s, extracted_data["babbling_reward_s"]; legend = "babbling equilibrium", color="darkgray", style = "dotted");
pl_expected_reward_s = plot_val!(pl_expected_reward_s, extracted_data["best_reply_expected_reward_s"]; legend = "best response", color="green!70!gray", style="dashed");

# ex-ante expected reward receiver
pl_expected_reward_r = plot_avg(extracted_data["avg_expected_reward_r"];
								title = "ex-ante expected reward (receiver)", 
								legend = "simulations", 
								color = "blue",
								legend_pos = "out_bottom");
pl_expected_reward_r = plot_val!(pl_expected_reward_r, extracted_data["best_expected_reward_r"]; legend = "optimal equilibrium", color = "red");
pl_expected_reward_r = plot_val!(pl_expected_reward_r, extracted_data["babbling_reward_r"]; legend = "babbling equilibrium", color = "darkgray", style = "dotted");
pl_expected_reward_r = plot_val!(pl_expected_reward_r, extracted_data["best_reply_expected_reward_r"]; legend = "best response", color = "green!70!gray", style="dashed");

# ex-ante aggregate expected reward
pl_expected_aggregate_reward = plot_avg(extracted_data["avg_expected_aggregate_reward"];
								title = "ex-ante expected aggregate reward", 
								legend = "simulations", 
								color = "blue",
								legend_pos = "out_bottom");
pl_expected_aggregate_reward = plot_val!(pl_expected_aggregate_reward, extracted_data["best_expected_aggregate_reward"]; legend = "optimal equilibrium", color = "red");
pl_expected_aggregate_reward = plot_val!(pl_expected_aggregate_reward, extracted_data["babbling_aggregate_reward"]; legend = "babbling equilibrium", color = "darkgray", style = "dotted");

# mutual information
pl_mutual_information = plot_avg(extracted_data["avg_mutual_information"];
								title = "normalized mutual information", 
								legend = "simulations", 
								ylabel = raw"$I$",
								color = "blue",
								legend_pos = "out_bottom");
pl_mutual_information = plot_val!(pl_mutual_information, extracted_data["best_mutual_information"]; legend = "optimal equilibrium", color = "red");
babbling_mutual_information = fill(extracted_data["best_mutual_information"][end],length(set_biases))
pl_mutual_information = plot_val!(pl_mutual_information, babbling_mutual_information; legend = "babbling equilibrium", color = "darkgray", style = "dotted");
pl_mutual_information = plot_eq_bound!(pl_mutual_information)


# absolute error
pl_absolute_error = plot_avg(extracted_data["avg_absolute_error_s"];
								title = "gain from best response", 
								ylabel = raw"$\epsilon$ ", 
								legend = "sender", 
								color = "red",
								ymin=-0.00025, ymax = 0.01,
								legend_pos = "out_bottom",
								additional = "scaled y ticks=false");
pl_absolute_error = plot_avg!(pl_absolute_error, extracted_data["avg_absolute_error_r"]; 
								legend = "receiver", 
								color = "blue");
pl_absolute_error = plot_val!(pl_absolute_error, extracted_data["q_max_absolute_error"]; 
								legend = raw"90\% $\epsilon$-Nash threshold", 
								color = "orange");
pl_absolute_error = plot_eq_bound!(pl_absolute_error)

# group plot of rewards for baseline case 
group_pl_expected_reward_s = plot_avg(extracted_data["avg_expected_reward_s"]; 
								title = "ex-ante expected reward (sender)",
								color = "blue");
group_pl_expected_reward_s = plot_val!(group_pl_expected_reward_s, extracted_data["best_expected_reward_s"]; color="red");
group_pl_expected_reward_s = plot_val!(group_pl_expected_reward_s, extracted_data["babbling_reward_s"]; color="darkgray", style = "dotted");
group_pl_expected_reward_s = plot_val!(group_pl_expected_reward_s, extracted_data["best_reply_expected_reward_s"]; color="green!70!gray", style="dashed");
group_pl_expected_reward_s = plot_eq_bound!(group_pl_expected_reward_s)

# ex-ante expected reward receiver
group_pl_expected_reward_r = plot_avg(extracted_data["avg_expected_reward_r"];
								title = "ex-ante expected reward (receiver)", 
								legend = "simulations", 
								color = "blue");
group_pl_expected_reward_r = plot_val!(group_pl_expected_reward_r, extracted_data["best_expected_reward_r"]; legend = "optimal equilibrium", color = "red");
group_pl_expected_reward_r = plot_val!(group_pl_expected_reward_r, extracted_data["babbling_reward_r"]; legend = "babbling equilibrium", color = "darkgray", style = "dotted");
group_pl_expected_reward_r = plot_val!(group_pl_expected_reward_r, extracted_data["best_reply_expected_reward_r"]; legend = "best response", color = "green!70!gray", style="dashed");
group_pl_expected_reward_r = plot_eq_bound!(group_pl_expected_reward_r)

push!(group_pl_expected_reward_r.options, "legend style={legend columns = -1, legend to name={legend_group_expected_rewards}, column sep = 5pt}")
group_pl_expected_rewards = @pgf GroupPlot(
							{ group_style = { group_size="2 by 1", raw"horizontal sep = 50pt" },
   							 }, group_pl_expected_reward_s, group_pl_expected_reward_r);

# mutual information
pl_n_episodes = plot_avg(extracted_data["avg_n_episodes"];
								title = "episodes to converge",								color = "blue",
								legend_pos = "out_bottom");


# save plots
pdf_dir = mkpath(joinpath(input_dir,"pdf"))
tikz_dir = mkpath(joinpath(input_dir,"tikz"))
pgfsave(joinpath(tikz_dir,"expected_reward_s.tikz"),pl_expected_reward_s)
pgfsave(joinpath(pdf_dir,"expected_reward_s.pdf"),pl_expected_reward_s)
pgfsave(joinpath(tikz_dir,"expected_reward_r.tikz"),pl_expected_reward_r)
pgfsave(joinpath(pdf_dir,"expected_reward_r.pdf"),pl_expected_reward_r)
pgfsave(joinpath(tikz_dir,"expected_aggregate_reward.tikz"),pl_expected_aggregate_reward)
pgfsave(joinpath(pdf_dir,"expected_aggregate_reward.pdf"),pl_expected_aggregate_reward)
pgfsave(joinpath(tikz_dir,"mutual_information.tikz"),pl_mutual_information)
pgfsave(joinpath(pdf_dir,"mutual_information.pdf"),pl_mutual_information)
pgfsave(joinpath(tikz_dir,"absolute_error.tikz"),pl_absolute_error)
pgfsave(joinpath(pdf_dir,"absolute_error.pdf"),pl_absolute_error)
pgfsave(joinpath(tikz_dir,"n_episodes.tikz"),pl_n_episodes)
pgfsave(joinpath(pdf_dir,"n_episodes.pdf"),pl_n_episodes)
pgfsave(joinpath(tikz_dir,"group_expected_rewards.tikz"),group_pl_expected_rewards)
pgfsave(joinpath(pdf_dir,"group_expected_rewards.pdf"),group_pl_expected_rewards)
