# This script generates plots from the simulations outcomes generated by 1_script.jl
# Usage:
# 1) navigate to the project directory 'rl_cheap_talk' 
# 2) run 'julia --threads NUM_THREADS scripts/1_plots.jl -i INPUT_DIR'
#	 replacing NUM_THREADS with the desired number of threads 
#    and INPUT_DIR with the output directory of 1_script.jl 

using PGFPlotsX
using StatsBase
using Base.Threads

include(joinpath(pwd(),"scripts","1_read_data.jl"))
extracted_data, best_nash, babbling_nash = read_data()

quantile_(data, alpha; dims = :) = mapslices(x -> quantile(x, alpha), data, dims=1)

function init_tikz_axis(;title, ylabel, ylabel_style, y_tick_label_style, additional, ymin, ymax, width, height)
	pl = @pgf Axis(
	    {	#
	    	title = title,
	    	xlabel = raw"$b$", ylabel = ylabel,
	    	xtick = 0:0.1:0.5, #ytick = "",
	        xmin = -0.0025, xmax = 0.5025,
	        ymin = ymin, ymax = ymax, 
	        #
			y_tick_label_style = y_tick_label_style,
	 		ylabel_style = ylabel_style,
	        scaled_y_ticks = true,
	        #
			width = width, 
	        height = height,
	        #
	        clip = true,
	        enlarge_y_limits=0.1,
			align = "center",
	    }
	);
    !isempty(additional) && push!(pl.options, additional)
	return pl
end

function add_legend!(pl, legend, pos)
   	push!(pl, LegendEntry(legend))
    if pos == "out_bottom" 
    	push!(pl.options, raw"xlabel style={name=xlabel}")
		push!(pl.options, raw"legend style={at={(xlabel.south)},anchor=north,legend columns = -1, column sep = 5pt}")
    elseif pos == "out_right"
    	push!(pl.options, raw"legend style={at={(axis description cs:1.1,0.5)},anchor=west}")
    end
end

function plot_avg(data; legend = "", title = "", ylabel = "", ylabel_style = "rotate=-90", color = "blue",
						y_tick_label_style = "{/pgf/number format/fixed, /pgf/number format/precision=4}",
						ymin = minimum(quantile_(data, 0.05, dims = 1)), 
						ymax = maximum(quantile_(data, 0.95, dims = 1)), 
						width = raw"0.475\linewidth", height = raw"0.35\linewidth",
						legend_pos = "", additional = "", ci_flag = true)

	# initialize tikz plot
	pl = init_tikz_axis(title = title, ylabel = ylabel, ylabel_style = ylabel_style, y_tick_label_style = y_tick_label_style, additional = additional, ymin = ymin, ymax = ymax, width = width, height = height)
	# plot average 
	pl = plot_avg!(pl, data; legend = legend, color = color, legend_pos = legend_pos, ci_flag = ci_flag)
	return pl
end


function plot_avg!(pl, data; α = 0.1, legend = "", color = "blue", legend_pos = "", ci_flag = true)
	# process data
 	n_simulations, n_biases = size(data)
 	set_biases_ = range(0.0, 0.5, n_biases)
	average = mean(data, dims = 1)[:]
    ci_flag && (confidence_interval = quantile_(data, [α/2, 1-α/2], dims = 1))
    # plot data
    @pgf pl_avg = Plot({color = color, style = "solid, thick"}, Table(x = set_biases_, y = average));
	push!(pl, pl_avg);
	if ci_flag == true
		@pgf pl_ub = Plot({"name path=f", no_marks, thin, "draw=none", "forget plot"}, Table(x = set_biases_, y = confidence_interval[2,:]));
		@pgf pl_lb = Plot({"name path=g", no_marks, thin, "draw=none", "forget plot"}, Table(x = set_biases_, y = confidence_interval[1,:]));
		@pgf pl_fill = Plot({color = color, fill = color, opacity = 0.1, "forget plot"}, raw"fill between [of=f and g]");
		push!(pl, pl_ub);
		push!(pl, pl_lb);
		push!(pl, pl_fill);
	end
    !isempty(legend) && add_legend!(pl, legend, legend_pos)
	return pl
end


function plot_dis(data; legend = "", title = "", ylabel = "", ylabel_style = "rotate=-90", color = "blue", 
						y_tick_label_style = "{/pgf/number format/fixed, /pgf/number format/precision=4}",
						ymin = minimum(quantile_(data, 0.05, dims = 1)), 
						ymax = maximum(quantile_(data, 0.95, dims = 1)), 
						width = raw"0.475\linewidth", height = raw"0.35\linewidth",
						n_steps = 45, legend_pos = "", additional = "")
	# input: data matrix of dimension n_simulations x n_bias

	# initialize tikz plot
	pl = init_tikz_axis(title = title, ylabel = ylabel, ylabel_style = ylabel_style, y_tick_label_style = y_tick_label_style, additional = additional, ymin = ymin, ymax = ymax, width = width, height = height)

	# process data
 	n_simulations, n_biases = size(data)
 	set_biases_ = range(0.0,0.5,n_biases)
	step_size = (ymax - ymin) / n_steps
	support = range(ymin - step_size/2, ymax + step_size/2, n_steps)

	# add heatmap options 
	push!(pl.options,
		#colorbar,
		#colorbar_sampled,
		"point meta max = $n_simulations",
		"point meta min = 0",
		"colormap={whiteblue}{color(0cm)=(white), color(1cm)=($color)}",
		"colorbar style = {scaled ticks=false, /pgf/number format/fixed, /pgf/number format/precision = 5}",
	)

    # plot data
	h_data = hcat([fit(Histogram, data[:,b], support).weights for b in 1:n_biases]...)
	x, y = repeat(set_biases_, outer = n_steps-1), repeat(support[2:end] .- step_size/2, inner = n_biases)
	coord = Coordinates(x, y; meta = vec(h_data'))
    @pgf pl_hm = Plot({ "matrix plot*", mark = "", point_meta = "explicit", "mesh/cols" = n_biases, on_layer = "axis background", clip = true, forget_plot}, coord)
	push!(pl, pl_hm);
    !isempty(legend) && add_legend!(pl, legend, legend_pos)
	!isempty(legend) && push!(pl, "\\addlegendimage{only marks, mark=square*, fill=$color, draw=$color, opacity = 0.7}")

	return pl
end


function plot_val!(pl, data; legend = "", color = "red", style = "solid", opacity = 1.0)
	# plot value on top of existing plot
	val = getindex.(data,1)
    set_biases_ = range(0.0,0.5,length(data))
    @pgf pl_val = Plot({axis_on_top, color = color, style = style, opacity = opacity}, Table(x = set_biases_, y = val));
	push!(pl, pl_val);
    !isempty(legend) && push!(pl, LegendEntry(legend))
	return pl
end

function plot_eq_bound!(pl)
	# plot shaded areas to indicate where babbling is the unique equilibrium and where full communication is an equilibrium
	set_biases_ = range(0.0,0.5,length(best_nash["best_mutual_information"]))
	# last index at which mutual information is 1.0
	mi1_idx = findlast(best_nash["best_mutual_information"] .== maximum(best_nash["best_mutual_information"]))
	# first index at which mutual information is 0.0
	mi0_idx = findfirst(best_nash["best_mutual_information"] .== minimum(best_nash["best_mutual_information"]))
	@pgf pl_best_lx_bound = VLine({"draw=none", "name path=blx"}, 0.0)
	@pgf pl_best_rx_bound = VLine({"draw=none", "name path=brx"}, set_biases_[mi1_idx])
	@pgf pl_best_fill = Plot({color = "gray", fill = "gray", opacity = 0.08}, raw"fill between [of=blx and brx]");
	@pgf pl_worst_lx_bound = VLine({"draw=none", "name path=wlx"}, set_biases_[mi0_idx])
	@pgf pl_worst_rx_bound = VLine({"draw=none", "name path=wrx"}, 0.5)
	@pgf pl_worst_fill = Plot({color = "gray", fill = "gray", opacity = 0.08}, raw"fill between [of=wlx and wrx]");
	push!(pl, pl_best_lx_bound);
	push!(pl, pl_best_rx_bound);
	push!(pl, pl_best_fill);
	push!(pl, pl_worst_lx_bound);
	push!(pl, pl_worst_rx_bound);
	push!(pl, pl_worst_fill);
end

function get_title_equation(agent_idx)
	sender_equation = ""
	receiver_equation = ""
	if scrpt_config["in_dir"] == "out_3states"
		sender_equation = raw"$|\Theta| = 3$ \\ "
		receiver_equation = raw"$|\Theta| = 3$ \\ "
	elseif scrpt_config["in_dir"] == "out_9states"
		sender_equation = raw"$|\Theta| = 9$ \\ "
		receiver_equation = raw"$|\Theta| = 9$ \\ "
	elseif scrpt_config["in_dir"] == "out_increasing"
		sender_equation = raw"$p(\theta_k)=2k / (n(n+1))$ \\ " 
		receiver_equation = raw"$p(\theta_k)=2k / (n(n+1))$ \\ "
	elseif scrpt_config["in_dir"] == "out_decreasing"
		sender_equation = raw"$p(\theta_k)=2 (n-k+1) / (n(n+1))$ \\ " 
		receiver_equation = raw"$p(\theta_k)=2 (n-k+1) / (n(n+1))$ \\ "
	elseif scrpt_config["in_dir"] == "out_fourthpower" 
		sender_equation = raw"$u_S(\theta,a) = -(a - \theta - b)^4$ \\ "
		receiver_equation = raw"$u_S(\theta,a) = -(a - \theta)^4$ \\ "
	elseif scrpt_config["in_dir"] == "out_absolute" 
		sender_equation = raw"$u_S(\theta,a) = -|a - \theta - b|$ \\ "
		receiver_equation = raw"$u_S(\theta,a) = -|a - \theta|$ \\ "
	elseif scrpt_config["in_dir"] == "out_less_messages"
		sender_equation = raw"$|M| = 3$ \\ "
		receiver_equation = raw"$|M| = 3$ \\ "
	elseif scrpt_config["in_dir"] == "out_more_messages"
		sender_equation = raw"$|M| = 9$ \\ "
		receiver_equation = raw"$|M| = 9$ \\ "
	elseif scrpt_config["in_dir"] == "out_less_actions"
		sender_equation = raw"$|A| = 6$ \\ "
		receiver_equation = raw"$|A| = 6$ \\ "
	elseif scrpt_config["in_dir"] == "out_more_actions"
		sender_equation = raw"$|A| = 16$ \\ "
		receiver_equation = raw"$|A| = 16$ \\ "
	end
	return (sender_equation, receiver_equation)[agent_idx]
end

# GENERATE PLOTS
push!(PGFPlotsX.CUSTOM_PREAMBLE, raw"\usepgfplotslibrary{fillbetween}")

# MUTUAL INFORMATION 
pl_mutual_information = plot_dis(extracted_data["mutual_information"];
								title = "normalized mutual information", 
								legend = "simulations", 
								ylabel = raw"$I$",
								color = "blue",
								legend_pos = "out_bottom",
								ymin=0, ymax=1);
pl_mutual_information = plot_val!(pl_mutual_information, best_nash["best_mutual_information"]; legend = "optimal equilibrium", color = "red", style = "solid, thick", opacity = 0.7);
babbling_mutual_information = fill(best_nash["best_mutual_information"][end],length(set_biases))
pl_mutual_information = plot_val!(pl_mutual_information, babbling_mutual_information; legend = "babbling equilibrium", color = "darkgray", style = "dotted");
pl_mutual_information = plot_eq_bound!(pl_mutual_information);

# EXPECTED REWARDS
# group plot of rewards for baseline case 
group_pl_expected_reward_s = plot_dis(extracted_data["expected_reward_s"]; 
								title = string(get_title_equation(1),"ex-ante expected reward (sender)"),
								color = "blue");
group_pl_expected_reward_s = plot_val!(group_pl_expected_reward_s, best_nash["best_expected_reward_s"]; color="red", style = "solid, thick", opacity = 0.7);
group_pl_expected_reward_s = plot_val!(group_pl_expected_reward_s, babbling_nash["babbling_reward_s"]; color="darkgray", style = "dotted");
group_pl_expected_reward_s = plot_eq_bound!(group_pl_expected_reward_s);

# ex-ante expected reward receiver
group_pl_expected_reward_r = plot_dis(extracted_data["expected_reward_r"];
								title = string(get_title_equation(2),"ex-ante expected reward (receiver)"), 
								legend = "simulations", 
								color = "blue");
group_pl_expected_reward_r = plot_val!(group_pl_expected_reward_r, best_nash["best_expected_reward_r"]; legend = "optimal equilibrium", color = "red", style = "solid, thick", opacity = 0.7);
group_pl_expected_reward_r = plot_val!(group_pl_expected_reward_r, babbling_nash["babbling_reward_r"]; legend = "babbling equilibrium", color = "darkgray", style = "dotted");
group_pl_expected_reward_r = plot_eq_bound!(group_pl_expected_reward_r);

# group plot expected reward
push!(group_pl_expected_reward_r.options, "legend style={legend columns = -1, legend to name={legend_group_expected_rewards}, column sep = 5pt}")
group_pl_expected_rewards = @pgf GroupPlot(
							{ group_style = { group_size="2 by 1", raw"horizontal sep = 50pt" },
   							 }, group_pl_expected_reward_s, group_pl_expected_reward_r);


# ABSOLUTE ERROR
#y_max = max(maximum(quantile_(extracted_data["absolute_error_s"], 0.95, dims = 1)), maximum(quantile_(extracted_data["absolute_error_r"], 0.95, dims = 1)))
y_max = max(maximum(mean(extracted_data["absolute_error_s"],dims = 1)), maximum(mean(extracted_data["absolute_error_r"], dims = 1)))
# group plot absolute error sender
pl_absolute_error_s = plot_avg(extracted_data["absolute_error_s"];
								title = raw"$U_S(\pi^S_*, \pi^R_\infty) - U_S(\pi^S_\infty, \pi^R_\infty)$ \\[-7pt]", 
								ylabel = raw"$\epsilon_S$ ",
								additional = raw"tick scale binop=\times",
								color = "red",
								ymin=0, ymax = y_max,
								ci_flag = false,
								width = raw"0.475\linewidth", height = raw"0.275\linewidth");
pl_absolute_error_s = plot_eq_bound!(pl_absolute_error_s);

# group plot absolute error reseicer
pl_absolute_error_r = plot_avg(extracted_data["absolute_error_r"];
								title = raw"$U_R(\pi^S_\infty, \pi^R_*) - U_S(\pi^S_\infty, \pi^R_\infty)$ \\[-7pt]", 
								ylabel = raw"$\epsilon_R$ ",
								additional = raw"tick scale binop=\times",
								color = "blue",
								ymin=0, ymax = y_max,
								ci_flag = false,
								width = raw"0.475\linewidth", height = raw"0.275\linewidth");
pl_absolute_error_r = plot_eq_bound!(pl_absolute_error_r);

# MAXIMUM MASS ON SUBOTPIMAL
#y_max = max(maximum(quantile_(extracted_data["max_mass_on_suboptim_s"], 0.95, dims = 1)), maximum(quantile_(extracted_data["max_mass_on_suboptim_r"], 0.95, dims = 1)))
y_max = max(maximum(mean(extracted_data["max_mass_on_suboptim_s"], dims = 1)), maximum(mean(extracted_data["max_mass_on_suboptim_r"], dims = 1)))
# group plot gamma sender
pl_max_mass_on_suboptim_s = plot_avg(extracted_data["max_mass_on_suboptim_s"];
								title = raw"$\max_{\theta \in \Theta} \sum_{m \notin M^*(\theta)} \pi^S_\infty(m \mid \theta)$", 
								ylabel = raw"$\gamma_S$", 						
								color = "red",
								ymin = 0, ymax = y_max,
								ci_flag = false,
								width = raw"0.475\linewidth", height = raw"0.275\linewidth");
pl_max_mass_on_suboptim_s = plot_eq_bound!(pl_max_mass_on_suboptim_s);

# group plot gamma receiver
pl_max_mass_on_suboptim_r = plot_avg(extracted_data["max_mass_on_suboptim_r"];
								title = raw"$\max_{m \in M} \sum_{a \notin A^*(m)} \pi^R_\infty(a \mid m)$", 
								ylabel = raw"$\gamma_R$", 
								color = "blue",
								ymin = 0, ymax = y_max,
								ci_flag = false,
								width = raw"0.475\linewidth", height = raw"0.275\linewidth");
pl_max_mass_on_suboptim_r = plot_eq_bound!(pl_max_mass_on_suboptim_r);

# GROUP PLOT ABSOLUTE ERRORS AND MAXIMUM MASS ON SUBOPTIMAL
group_pl_errors = @pgf GroupPlot(
							{ group_style = { group_size="2 by 2", raw"horizontal sep = 50pt, vertical sep = 60pt" },
   							 }, pl_max_mass_on_suboptim_s, pl_max_mass_on_suboptim_r, pl_absolute_error_s, pl_absolute_error_r);



# IS GAMMA NASH
is_gamma_nash = extracted_data["max_max_mass_on_suboptim"] .< 1f-2
pl_is_gamma_nash = plot_avg(is_gamma_nash;
								title = raw"$max\{\gamma_S,\gamma_R\} < 0.01$",
								color = "green!80!black",
								legend_pos = "out_bottom",
								additional = "axis y discontinuity=parallel",
								ymin=0.55,
								ci_flag = false,
								width = raw"0.475\linewidth", height = raw"0.275\linewidth");
pl_is_gamma_nash = plot_eq_bound!(pl_is_gamma_nash);

# IS EPSILON NASH
is_epsilon_nash = extracted_data["max_absolute_error"] .< 1f-4
pl_is_epsilon_nash = plot_avg(is_epsilon_nash;
								title = raw"$max\{\epsilon_S,\epsilon_R\} < 10^{-4}$",
								color = "magenta",
								legend_pos = "out_bottom",
								additional = "axis y discontinuity=parallel",
								ymin=0.55,
								ci_flag = false,
								width = raw"0.475\linewidth", height = raw"0.275\linewidth");
pl_is_epsilon_nash = plot_eq_bound!(pl_is_epsilon_nash);

group_pl_nash = @pgf GroupPlot(
							{ group_style = { group_size="2 by 1", raw"horizontal sep = 50pt" },
   							 }, pl_is_gamma_nash, pl_is_epsilon_nash);



# ON PATH MESSAGES
pl_on_path_messages = plot_dis(extracted_data["n_on_path_messages"]; 
								title = "on-path", 
								color = "red",
								ymin= 0, ymax = maximum(extracted_data["n_on_path_messages"]),
								width = raw"0.3166\linewidth");
pl_on_path_messages = plot_eq_bound!(pl_on_path_messages);
# EFFECTIVE MESSAGES
pl_effective_messages = plot_dis(extracted_data["n_effective_messages"]; 
								title = "effective", 
								color = "blue",
								ymin= 0, ymax = maximum(extracted_data["n_on_path_messages"]),
								width = raw"0.3166\linewidth");
pl_effective_messages = plot_eq_bound!(pl_effective_messages);
# SYNONIMS
pl_synonyms = plot_dis(extracted_data["n_on_path_messages"]-extracted_data["n_effective_messages"]; 
								title = "synonyms", 
								color = "green",
								ymin= 0, ymax = maximum(extracted_data["n_on_path_messages"]),
								width = raw"0.3166\linewidth");
pl_synonyms = plot_eq_bound!(pl_synonyms);
# GROUP WORDS
group_pl_words = @pgf GroupPlot(
							{ group_style = { group_size="3 by 1", raw"horizontal sep = 25pt" },
   							 }, pl_on_path_messages, pl_effective_messages, pl_synonyms);


# IS PARTITIONAL
pl_is_partitional = plot_dis(extracted_data["is_partitional"]; 
								title = "is partitional", 
								ymin = 0, ymax = 1);
pl_is_partitional = plot_avg!(pl_is_partitional, extracted_data["is_partitional"]; ci_flag = false);
pl_is_partitional = plot_eq_bound!(pl_is_partitional);

# N EPISODES
pl_n_episodes = plot_avg(extracted_data["n_episodes"];
								title = "episodes to converge",color = "blue",
								legend_pos = "out_bottom");
pl_n_episodes = plot_eq_bound!(pl_n_episodes);


# save plots
pdf_dir = mkpath(joinpath(input_dir,"pdf"))
tikz_dir = mkpath(joinpath(input_dir,"tikz"))

function save_plots(tikz_dir, pdf_dir, file_name, plot)
    pgfsave(joinpath(tikz_dir, "$file_name.tikz"), plot)
    pgfsave(joinpath(pdf_dir, "$file_name.pdf"), plot)
end

plots = [
    	("group_expected_rewards", group_pl_expected_rewards),
    	("mutual_information", pl_mutual_information),
    	("group_errors", group_pl_errors),
    	("group_nash", group_pl_nash),
    	("group_words", group_pl_words),
    	("is_partitional", pl_is_partitional),
    	("n_episodes", pl_n_episodes)
	]

counter = Atomic{Int}(0)
total_plots = length(plots)

Threads.@threads for (file_name, plot) in plots
    save_plots(tikz_dir, pdf_dir, file_name, plot)
    atomic_add!(counter, 1)
    # Update progress on the same line
    print("\rGenerating plots $(counter[])/$total_plots")
    flush(stdout)
end
println()




#=
changes = findall(benchmark[1:end-1] .!= benchmark[2:end]) .+ 1
pushfirst!(changes,1)
push!(changes,length(benchmark))
midpoints = div.((changes[1:end-1] .+ changes[2:end]),2)
x_coords = set_biases_[midpoints]
y_coords = benchmark[midpoints] .- (benchmark[1] - benchmark[end]) / 100
labels = Int.(extracted_data["n_messages_on_path"][changes[1:end-1]])
for i in eachindex(x_coords)
    latex_string = "\\node at (axis cs:$(x_coords[i]),$(y_coords[i])) [anchor=south, red, opacity=0.5] {\\tiny \$$(labels[i])\$};"
    push!(pl, PGFPlotsX.Expression(latex_string))
end
=#
