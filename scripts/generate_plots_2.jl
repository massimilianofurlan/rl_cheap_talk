# This script generates plots from the simulations outcomes generated by 2_script.jl
# Usage:
# 1) navigate to the project directory 'rl_cheap_talk' 
# 2) run 'julia --threads NUM_THREADS scripts/generate_plots_2.jl -i INPUT_DIR'
#	 replacing NUM_THREADS with the desired number of threads 
#    and INPUT_DIR with the output directory of 2_script.jl 

# load dependencie
using PGFPlotsX
using StatsBase
using Base.Threads

include(joinpath(pwd(),"scripts/plots.jl"))
include(joinpath(pwd(),"scripts/read_data.jl"))

# parse terminal config
const scrpt_config = parse_commandline("out_grid_search", 0.01f0)
# define set of biases 
const set_biases = collect(0.00f0:scrpt_config["step_bias"]:0.5f0)
# define input dir 
const input_dir = joinpath(pwd(), scrpt_config["in_dir"])

# grid config
const min_alpha = 0.025f0
const n_alpha = 5
const min_lambda = 0.00002f0
const n_lambda = 5
# set of alphas/lambdas to loop over
const set_alpha::Array{Float32,1} = [min_alpha*2^(i-1) for i in 1:n_alpha]
const set_lambda::Array{Float32,1} = [min_lambda/2^(i-1) for i in 1:n_lambda]

println("\nInput dir: ", scrpt_config["in_dir"])

n_biases, n_simulations = length(set_biases), 1000

posterior_mean_variance = fill(NaN, n_alpha, n_lambda, n_simulations, n_biases);
expected_reward_s = fill(NaN, n_alpha, n_lambda, n_simulations, n_biases);
expected_reward_r = fill(NaN, n_alpha, n_lambda, n_simulations, n_biases);
max_max_mass_on_suboptim = fill(NaN, n_alpha, n_lambda, n_simulations, n_biases);
max_absolute_error = fill(NaN, n_alpha, n_lambda, n_simulations, n_biases);
is_nash = fill(NaN, n_alpha, n_lambda, n_simulations, n_biases);
n_episodes = fill(NaN, n_alpha, n_lambda, n_simulations, n_biases);
is_converged = fill(NaN, n_alpha, n_lambda, n_simulations, n_biases);
ranks = fill(NaN, n_alpha, n_lambda, n_simulations, n_biases);
babbling_reward_r = fill(NaN, n_alpha, n_lambda, n_biases);

for dir in readdir(input_dir, join = true)
	isdir(dir) || continue
	println("\nCurrent dir: ", basename(dir))
	config, extracted_data = read_data(dir)
	config != nothing || continue # 
	alpha::Float32, expl_decay::Float32 = config["alpha_s"], config["expl_decay_s"]
	alpha_idx, lambda_idx = findfirst(set_alpha .== alpha), findfirst(set_lambda .== expl_decay)

	expected_reward_s[alpha_idx,lambda_idx,:,:] .= cat(extracted_data["expected_reward_s"]...,dims=2);
	expected_reward_r[alpha_idx,lambda_idx,:,:] .= cat(extracted_data["expected_reward_r"]...,dims=2);
	posterior_mean_variance[alpha_idx,lambda_idx,:,:] .= cat(extracted_data["posterior_mean_variance"]...,dims=2);
	max_max_mass_on_suboptim[alpha_idx,lambda_idx,:,:] .= cat(extracted_data["max_max_mass_on_suboptim"]...,dims=2);
	max_absolute_error[alpha_idx,lambda_idx,:,:] .= cat(extracted_data["max_absolute_error"]...,dims=2);
	is_nash[alpha_idx,lambda_idx,:,:] .= cat(extracted_data["max_max_mass_on_suboptim"]...,dims=2) .< 1f-2 
	n_episodes[alpha_idx,lambda_idx,:,:] .= cat(extracted_data["n_episodes"]...,dims=2);
	is_converged[alpha_idx,lambda_idx,:,:] .= cat(extracted_data["is_converged"]...,dims=2);
	babbling_reward_r[alpha_idx,lambda_idx,:] .= extracted_data["babbling_reward_r"]
end

mean_(x; dims=:) = dropdims(mean(x,dims=dims),dims=dims)
avg_expected_reward_s = mean_(expected_reward_s,dims=3)
avg_expected_reward_r = mean_(expected_reward_r,dims=3)
avg_posterior_mean_variance = mean_(posterior_mean_variance,dims=3)
avg_max_max_mass_on_suboptim = mean_(max_max_mass_on_suboptim,dims=3)
avg_max_absolute_error = mean_(max_absolute_error,dims=3)
avg_is_nash = mean_(is_nash,dims=3)
avg_n_episodes = mean_(n_episodes,dims=3)
avg_is_converged = mean_(is_converged,dims=3)

set_nash, best_nash = get_equilibria(1001)

# colden ratio
const ratio = 4/3

push!(PGFPlotsX.CUSTOM_PREAMBLE, raw"\usepgfplotslibrary{fillbetween}")

format_scientific(x) = string(round(x / 10.0^floor(Int, log10(abs(x))), digits=2), " \\times 10^{", floor(Int, log10(abs(x))), "}")

pls_expected_reward_r = Axis[]
pls_posterior_mean_variance = Axis[]
pls_is_gamma_nash = Axis[]
for alpha_idx in 5:-1:1, lambda_idx in 1:1:5
	ylabel_ = lambda_idx == 1 ? string(raw"$",set_alpha[alpha_idx],raw"$") : ""
	xlabel_ = alpha_idx == 1 ? string(raw"$",format_scientific(set_lambda[lambda_idx]),raw"$") : ""
	ylabel_ = lambda_idx == 1 && alpha_idx == 3 ? string(raw"$\alpha$ \quad $",set_alpha[alpha_idx],raw"$") : ylabel_
	xlabel_ = alpha_idx == 1 && lambda_idx == 3 ? string(raw"$",format_scientific(set_lambda[lambda_idx]),raw"$ \\[5pt] $\lambda$") : xlabel_
	axis_style = lambda_idx == 3 && alpha_idx == 3 ? "axis line style={line width=0.75pt}" : ""

	# EXPECTED REWARD RECEIVER
	#pl_expected_reward_r = plot_dist(expected_reward_r[alpha_idx,lambda_idx,:,:];
	#								ylabel = ylabel_, xlabel = xlabel_,
	#								color = "blue",
	#								additional = "ticks=none",
	#								width = 0.375, height = 0.375 * ratio^(-1));
	#pl_expected_reward_r = plot_val!(pl_expected_reward_r, best_nash["best_expected_reward_r"]; color = "red", style = "solid, line width=1.8pt", opacity = 0.4);
	#pl_expected_reward_r = plot_val!(pl_expected_reward_r, babbling_reward_r[alpha_idx,lambda_idx,:]; color = "darkgray", style = "dotted");
	#pl_expected_reward_r = plot_eq_bound!(pl_expected_reward_r);

	# POSTERIOR MEAN VARIANCE
	pl_posterior_mean_variance = plot_dist(posterior_mean_variance[alpha_idx,lambda_idx,:,:];
									ylabel = ylabel_, xlabel = xlabel_,
									color = "blue",
									ymin=0, ymax=1, n_steps=65,
									additional = "ticks=none",
									width = 0.375, height = 0.375 * ratio^(-1));
	pl_posterior_mean_variance = plot_interpolated_val!(pl_posterior_mean_variance, best_nash["posterior_mean_variance"]; color = "red", style = "solid, line width=1.8pt", opacity = 0.4, ymin=0, ymax=1, n_steps=65);
	babbling_posterior_mean_variance = fill(best_nash["posterior_mean_variance"][end],length(set_biases))
	pl_posterior_mean_variance = plot_val!(pl_posterior_mean_variance, babbling_posterior_mean_variance; color = "darkgray", style = "dotted");
	pl_posterior_mean_variance = plot_eq_bound!(pl_posterior_mean_variance,best_nash["posterior_mean_variance"]);

	# IS NASH
	pl_is_gamma_nash = plot_avg(is_nash[alpha_idx,lambda_idx,:,:];
									ylabel = ylabel_, xlabel = xlabel_,
									color = "green!80!black",
									ymin=0,
									ci_flag = false,
									additional = string("ticks=none, ",axis_style),
									width = 0.27, height = 0.27 * ratio^(-1));
	pl_is_gamma_nash = plot_eq_bound!(pl_is_gamma_nash,best_nash["posterior_mean_variance"]);
	@pgf push!(pl_is_gamma_nash, HLine({"color = gray", "style = dashed, very thin", "on layer = axis background"}, 0))
	@pgf push!(pl_is_gamma_nash, HLine({"color = gray", "style = dashed, very thin", "on layer = axis background"}, 1))

	push!(pls_posterior_mean_variance, pl_posterior_mean_variance)
	push!(pls_is_gamma_nash, pl_is_gamma_nash)
end

group_pl_posterior_mean_variance = @pgf GroupPlot(
							{ group_style = { group_size="3 by 3", raw"horizontal sep = 10pt", raw"vertical sep = 10pt" },
   							 }, pls_posterior_mean_variance[[1,3,5,11,13,15,21,23,25]]...);

group_pl_is_gamma_nash = @pgf GroupPlot(
							{ group_style = { group_size="5 by 5", raw"horizontal sep = 5pt", raw"vertical sep = 5pt" },
   							 }, pls_is_gamma_nash...);



# save plots
pdf_dir = mkpath(joinpath(input_dir,"pdf"))
tikz_dir = mkpath(joinpath(input_dir,"tikz"))

function save_plots(tikz_dir, pdf_dir, file_name, plot)
    pgfsave(joinpath(tikz_dir, "$file_name.tikz"), plot)
    pgfsave(joinpath(pdf_dir, "$file_name.pdf"), plot)
end

plots = [
    	("grid_posterior_mean_variance", group_pl_posterior_mean_variance),
       	("grid_is_gamma_nash", group_pl_is_gamma_nash),
	]

counter = Atomic{Int}(0)
total_plots = length(plots)

Threads.@threads for (file_name, plot) in plots
    save_plots(tikz_dir, pdf_dir, file_name, plot)
    atomic_add!(counter, 1)
    print("\rGenerating plots $(counter[])/$total_plots")
    flush(stdout)
end
println()
