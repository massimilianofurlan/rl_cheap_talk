# This script generates plots from the simulations outcomes generated by 1_script.jl
# Usage:
# 1) navigate to the project directory 'rl_cheap_talk' 
# 2) run 'julia --threads NUM_THREADS scripts/1_plots.jl -i INPUT_DIR'
#	 replacing NUM_THREADS with the desired number of threads 
#    and INPUT_DIR with the output directory of 1_script.jl 

using PGFPlotsX
using StatsBase
using Base.Threads

include(joinpath(pwd(),"scripts/plots.jl"))
include(joinpath(pwd(),"scripts/1_read_data.jl"))

# parse terminal config
const scrpt_config = parse_commandline("out_basecase", 0.005f0)
# define set of biases 
const set_biases = collect(0.00f0:scrpt_config["step_bias"]:0.5f0)
# define input dir 
const input_dir = joinpath(pwd(), scrpt_config["in_dir"])

# navigate to relevant subdir 
dirs = readdir(input_dir, join = true)
dirs = dirs[isdir.(dirs)]
dirs = setdiff(dirs,joinpath.(input_dir,["pdf", "temp", "tikz"]))
dir_id = 1
if length(dirs) > 1
	println("list of directories: ")
	for (dir_id, dir) in enumerate(dirs)
		println(dir_id,": ", split(dir,"/")[end])
	end
	while true
		print("select directory: ")
		global dir_id = parse(Int, readline())
		dir_id in keys(dirs) && break
	end
end

println("\nInput dir: ", scrpt_config["in_dir"])
_, extracted_data, babbling_nash, policies = read_data(dirs[dir_id])
set_nash, best_nash = get_equilibria(1001)

# GENERATE PLOTS
push!(PGFPlotsX.CUSTOM_PREAMBLE, raw"\usepgfplotslibrary{fillbetween}")

# MUTUAL INFORMATION 
pl_mutual_information = plot_dist(extracted_data["mutual_information"];
								title = "normalized mutual information", 
								legend = "simulations", 
								ylabel = raw"$I$",
								color = "blue",
								legend_pos = "out_bottom",
								ymin=0, ymax=1);
pl_mutual_information = plot_val!(pl_mutual_information, best_nash["best_mutual_information"]; legend = "optimal equilibrium", color = "red", style = "solid, thick", opacity = 0.7);
babbling_mutual_information = fill(best_nash["best_mutual_information"][end],length(set_biases))
pl_mutual_information = plot_val!(pl_mutual_information, babbling_mutual_information; legend = "babbling equilibrium", color = "darkgray", style = "dotted");
pl_mutual_information = plot_eq_bound!(pl_mutual_information);

# EXPECTED REWARDS
# group plot of rewards for baseline case 
group_pl_expected_reward_s = plot_dist(extracted_data["expected_reward_s"]; 
								title = string(get_title_equation(1),"ex-ante expected reward (sender)"),
								color = "blue");
group_pl_expected_reward_s = plot_val!(group_pl_expected_reward_s, best_nash["best_expected_reward_s"]; color="red", style = "solid, thick", opacity = 0.7);
group_pl_expected_reward_s = plot_val!(group_pl_expected_reward_s, babbling_nash["babbling_reward_s"]; color="darkgray", style = "dotted");
group_pl_expected_reward_s = plot_eq_bound!(group_pl_expected_reward_s);

# ex-ante expected reward receiver
group_pl_expected_reward_r = plot_dist(extracted_data["expected_reward_r"];
								title = string(get_title_equation(2),"ex-ante expected reward (receiver)"), 
								legend = "simulations", 
								color = "blue");
group_pl_expected_reward_r = plot_val!(group_pl_expected_reward_r, best_nash["best_expected_reward_r"]; legend = "optimal equilibrium", color = "red", style = "solid, thick", opacity = 0.7);
group_pl_expected_reward_r = plot_val!(group_pl_expected_reward_r, babbling_nash["babbling_reward_r"]; legend = "babbling equilibrium", color = "darkgray", style = "dotted");
group_pl_expected_reward_r = plot_eq_bound!(group_pl_expected_reward_r);

# group plot expected reward
push!(group_pl_expected_reward_r.options, "legend style={legend columns = -1, legend to name={legend_group_expected_rewards}, column sep = 5pt}")
group_pl_expected_rewards = @pgf GroupPlot(
							{ group_style = { group_size="2 by 1", raw"horizontal sep = 50pt" },
   							 }, group_pl_expected_reward_s, group_pl_expected_reward_r);


# ABSOLUTE ERROR
#y_max = max(maximum(quantile_(extracted_data["absolute_error_s"], 0.95, dims = 1)), maximum(quantile_(extracted_data["absolute_error_r"], 0.95, dims = 1)))
y_max = max(maximum(mean(extracted_data["absolute_error_s"],dims = 1)), maximum(mean(extracted_data["absolute_error_r"], dims = 1)))
# group plot absolute error sender
pl_absolute_error_s = plot_avg(extracted_data["absolute_error_s"];
								title = raw"$U_S(\pi^S_*, \pi^R_\infty) - U_S(\pi^S_\infty, \pi^R_\infty)$ \\[-7pt]", 
								ylabel = raw"$\epsilon_S$ ",
								additional = raw"tick scale binop=\times",
								color = "red",
								ymin=0, ymax = y_max,
								ci_flag = false,
								width = raw"0.475\linewidth", height = raw"0.275\linewidth");
pl_absolute_error_s = plot_eq_bound!(pl_absolute_error_s);

# group plot absolute error reseicer
pl_absolute_error_r = plot_avg(extracted_data["absolute_error_r"];
								title = raw"$U_R(\pi^S_\infty, \pi^R_*) - U_S(\pi^S_\infty, \pi^R_\infty)$ \\[-7pt]", 
								ylabel = raw"$\epsilon_R$ ",
								additional = raw"tick scale binop=\times",
								color = "blue",
								ymin=0, ymax = y_max,
								ci_flag = false,
								width = raw"0.475\linewidth", height = raw"0.275\linewidth");
pl_absolute_error_r = plot_eq_bound!(pl_absolute_error_r);

# MAXIMUM MASS ON SUBOTPIMAL
#y_max = max(maximum(quantile_(extracted_data["max_mass_on_suboptim_s"], 0.95, dims = 1)), maximum(quantile_(extracted_data["max_mass_on_suboptim_r"], 0.95, dims = 1)))
y_max = max(maximum(mean(extracted_data["max_mass_on_suboptim_s"], dims = 1)), maximum(mean(extracted_data["max_mass_on_suboptim_r"], dims = 1)))
# group plot gamma sender
pl_max_mass_on_suboptim_s = plot_avg(extracted_data["max_mass_on_suboptim_s"];
								title = raw"$\max_{\theta \in \Theta} \sum_{m \notin M^*(\theta)} \pi^S_\infty(m \mid \theta)$", 
								ylabel = raw"$\gamma_S$", 						
								color = "red",
								ymin = 0, ymax = y_max,
								ci_flag = false,
								width = raw"0.475\linewidth", height = raw"0.275\linewidth");
pl_max_mass_on_suboptim_s = plot_eq_bound!(pl_max_mass_on_suboptim_s);

# group plot gamma receiver
pl_max_mass_on_suboptim_r = plot_avg(extracted_data["max_mass_on_suboptim_r"];
								title = raw"$\max_{m \in M} \sum_{a \notin A^*(m)} \pi^R_\infty(a \mid m)$", 
								ylabel = raw"$\gamma_R$", 
								color = "blue",
								ymin = 0, ymax = y_max,
								ci_flag = false,
								width = raw"0.475\linewidth", height = raw"0.275\linewidth");
pl_max_mass_on_suboptim_r = plot_eq_bound!(pl_max_mass_on_suboptim_r);

# GROUP PLOT ABSOLUTE ERRORS AND MAXIMUM MASS ON SUBOPTIMAL
group_pl_errors = @pgf GroupPlot(
							{ group_style = { group_size="2 by 2", raw"horizontal sep = 50pt, vertical sep = 60pt" },
   							 }, pl_max_mass_on_suboptim_s, pl_max_mass_on_suboptim_r, pl_absolute_error_s, pl_absolute_error_r);



# IS GAMMA NASH
is_gamma_nash = extracted_data["max_max_mass_on_suboptim"] .< 1f-2
pl_is_gamma_nash = plot_avg(is_gamma_nash;
								title = raw"$max\{\gamma_S,\gamma_R\} < 0.01$",
								color = "green!80!black",
								legend_pos = "out_bottom",
								additional = "axis y discontinuity=parallel",
								ymin=0.55,
								ci_flag = false,
								width = raw"0.475\linewidth", height = raw"0.275\linewidth");
pl_is_gamma_nash = plot_eq_bound!(pl_is_gamma_nash);

# IS EPSILON NASH
is_epsilon_nash = extracted_data["max_absolute_error"] .< 1f-4
pl_is_epsilon_nash = plot_avg(is_epsilon_nash;
								title = raw"$max\{\epsilon_S,\epsilon_R\} < 10^{-4}$",
								color = "magenta",
								legend_pos = "out_bottom",
								additional = "axis y discontinuity=parallel",
								ymin=0.55,
								ci_flag = false,
								width = raw"0.475\linewidth", height = raw"0.275\linewidth");
pl_is_epsilon_nash = plot_eq_bound!(pl_is_epsilon_nash);

group_pl_nash = @pgf GroupPlot(
							{ group_style = { group_size="2 by 1", raw"horizontal sep = 50pt" },
   							 }, pl_is_gamma_nash, pl_is_epsilon_nash);



# ON PATH MESSAGES
pl_on_path_messages = plot_dist(extracted_data["n_on_path_messages"]; 
								title = "on-path", 
								color = "red",
								ymin= 0, ymax = maximum(extracted_data["n_on_path_messages"]),
								width = raw"0.3166\linewidth");
pl_on_path_messages = plot_eq_bound!(pl_on_path_messages);
# EFFECTIVE MESSAGES
pl_effective_messages = plot_dist(extracted_data["n_effective_messages"]; 
								title = "effective", 
								color = "blue",
								ymin= 0, ymax = maximum(extracted_data["n_on_path_messages"]),
								width = raw"0.3166\linewidth");
pl_effective_messages = plot_eq_bound!(pl_effective_messages);
# SYNONIMS
pl_synonyms = plot_dist(extracted_data["n_on_path_messages"]-extracted_data["n_effective_messages"]; 
								title = "synonyms", 
								color = "green",
								ymin= 0, ymax = maximum(extracted_data["n_on_path_messages"]),
								width = raw"0.3166\linewidth");
pl_synonyms = plot_eq_bound!(pl_synonyms);
# GROUP WORDS
group_pl_words = @pgf GroupPlot(
							{ group_style = { group_size="3 by 1", raw"horizontal sep = 25pt" },
   							 }, pl_on_path_messages, pl_effective_messages, pl_synonyms);


# IS PARTITIONAL
pl_is_partitional = plot_dist(extracted_data["is_partitional"]; 
								title = "is partitional", 
								ymin = 0, ymax = 1);
pl_is_partitional = plot_avg!(pl_is_partitional, extracted_data["is_partitional"]; ci_flag = false);
pl_is_partitional = plot_eq_bound!(pl_is_partitional);

# N EPISODES
pl_n_episodes = plot_avg(extracted_data["n_episodes"];
								title = "episodes to converge",color = "blue",
								legend_pos = "out_bottom");
pl_n_episodes = plot_eq_bound!(pl_n_episodes);


# AVERAGE POLICIES
bias_idxs = [1, 6, 16, 36, 76]
group_policies_s, group_policies_r = [], []

# compute modal policies
for bias_idx in bias_idxs
	policies_s = policies["s"][bias_idx]
	policies_r = policies["r"][bias_idx]
	unique_policies_s = unique(policies_s,dims=3)
	unique_policies_r = unique(policies_r,dims=3)
	freq_policy_s = [count(all(policies_s .== unique_policies_s[:,:,z],dims=1:2)) for z in 1:size(unique_policies_s,3)]
	freq_policy_r = [count(all(policies_r .== unique_policies_r[:,:,z],dims=1:2)) for z in 1:size(unique_policies_r,3)]
	modal_policy_s = unique_policies_s[:,:,argmax(freq_policy_s)]
	modal_policy_r = unique_policies_r[:,:,argmax(freq_policy_r)]
	#avg_policy_s = mean(policies_s, dims=3)
	#avg_policy_r = mean(policies_r, dims=3)
	hm_modal_policy_s = plot_policy(modal_policy_s, raw"$\theta$", bias_idx == 1 ? raw"$m$" : "", 0:0.5:1, bias_idx == 1 ? (1:n_messages) : "", (n_states-1)/2, 1, string(raw"$b=",set_biases[bias_idx],raw"$"));
	hm_modal_policy_r = plot_policy(modal_policy_r, raw"$m$",  bias_idx == 1 ? raw"$a$" : "", 1:n_messages, bias_idx == 1 ? (0:0.25:1) : "", 1, (n_actions-1)/4, "");
	n_on_path_messages = findlast(sum(modal_policy_s, dims=1) .> 0.01)[2];
	@pgf push!(hm_modal_policy_r,VLine({loosely_dashed, black}, n_on_path_messages+0.5));
	@pgf push!(hm_modal_policy_s,HLine({loosely_dashed, black}, n_messages-n_on_path_messages+0.5));
	push!(group_policies_s, hm_modal_policy_s)
	push!(group_policies_r, hm_modal_policy_r)
end
group_pl_policies = @pgf GroupPlot(
							{ group_style = { group_size="5 by 2", raw"horizontal sep = 10pt", raw"vertical sep = 35pt" },
   							 }, group_policies_s..., group_policies_r...);


# save plots
pdf_dir = mkpath(joinpath(input_dir,"pdf"))
tikz_dir = mkpath(joinpath(input_dir,"tikz"))

function save_plots(tikz_dir, pdf_dir, file_name, plot)
    pgfsave(joinpath(tikz_dir, "$file_name.tikz"), plot)
    pgfsave(joinpath(pdf_dir, "$file_name.pdf"), plot)
end

plots = [
    	("group_expected_rewards", group_pl_expected_rewards),
       	("group_policies", group_pl_policies),
    	("mutual_information", pl_mutual_information),
    	("group_errors", group_pl_errors),
    	("group_nash", group_pl_nash),
    	("group_words", group_pl_words),
    	("is_partitional", pl_is_partitional),
    	("n_episodes", pl_n_episodes)
	]

counter = Atomic{Int}(0)
total_plots = length(plots)

Threads.@threads for (file_name, plot) in plots
    save_plots(tikz_dir, pdf_dir, file_name, plot)
    atomic_add!(counter, 1)
    print("\rGenerating plots $(counter[])/$total_plots")
    flush(stdout)
end
println()
